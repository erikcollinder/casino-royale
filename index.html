<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interloom - Casino Royale</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Hedvig+Letters+Serif:opsz@12..24&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Geist+Mono:wght@400;500;600&display=swap" rel="stylesheet">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #0a0a0a;
            font-family: 'Geist Mono', monospace;
            cursor: none;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        canvas {
            display: block;
        }

        /* Custom cursor */
        .custom-cursor {
            position: fixed;
            width: 20px;
            height: 20px;
            border: 2px solid #D4AF37;
            border-radius: 50%;
            pointer-events: none;
            z-index: 9999;
            transform: translate(-50%, -50%);
            transition: transform 0.1s ease, border-color 0.3s ease;
            mix-blend-mode: difference;
        }

        .custom-cursor::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            background: #D4AF37;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }

        .cursor-glow {
            position: fixed;
            width: 150px;
            height: 150px;
            background: radial-gradient(circle, rgba(212, 175, 55, 0.15) 0%, transparent 70%);
            pointer-events: none;
            z-index: 9998;
            transform: translate(-50%, -50%);
        }

        /* Overlay content */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            pointer-events: none;
            text-align: center;
            padding: 2rem;
        }

        .glass-panel {
            background: rgba(10, 10, 10, 0.4);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(212, 175, 55, 0.2);
            border-radius: 20px;
            padding: 4rem 5rem;
            max-width: 700px;
        }

        .logo-placeholder {
            width: 200px;
            height: 60px;
            margin: 0 auto 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transform: translateY(20px);
            animation: fadeSlideUp 1s ease forwards;
            animation-delay: 1s;
        }

        .logo-text {
            font-size: 2.5rem;
            font-weight: 700;
            color: #D4AF37;
            letter-spacing: 0.3em;
            text-transform: uppercase;
        }

        .invite-line {
            color: #FFF8E7;
            font-size: 0.9rem;
            font-weight: 400;
            letter-spacing: 0.08em;
            margin-bottom: 2.5rem;
            opacity: 0;
            transform: translateY(20px);
            animation: fadeSlideUp 0.8s ease forwards;
            animation-delay: 1.5s;
            text-transform: lowercase;
        }

        .main-title {
            font-family: 'Hedvig Letters Serif', Georgia, serif;
            font-size: 2.8rem;
            font-weight: 400;
            color: #D4AF37;
            letter-spacing: -0.01em;
            margin-bottom: 3rem;
            text-shadow: 0 0 40px rgba(212, 175, 55, 0.5);
            overflow: hidden;
        }

        .main-title span {
            display: inline-block;
            opacity: 0;
            transform: translateY(100%);
            animation: letterReveal 0.5s ease forwards;
        }

        .details {
            opacity: 0;
            transform: translateY(20px);
            animation: fadeSlideUp 1s ease forwards;
            animation-delay: 3.5s;
        }

        .detail-item {
            color: #FFF8E7;
            font-size: 0.95rem;
            font-weight: 400;
            letter-spacing: 0.04em;
            margin: 0.8rem 0;
        }

        .detail-item.dresscode {
            font-weight: 500;
            color: #D4AF37;
            font-size: 1.05rem;
            margin-bottom: 1.5rem;
        }

        .detail-item.location {
            margin-top: 1.5rem;
        }

        .divider {
            width: 100px;
            height: 1px;
            background: linear-gradient(90deg, transparent, #D4AF37, transparent);
            margin: 1.5rem auto;
        }

        @keyframes fadeSlideUp {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes letterReveal {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Vignette effect */
        .vignette {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
            background: radial-gradient(ellipse at center, transparent 0%, transparent 40%, rgba(0,0,0,0.7) 100%);
        }

        /* Loading screen */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #0a0a0a;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: opacity 1s ease;
        }

        .loading-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loading-text {
            color: #D4AF37;
            font-size: 1.5rem;
            letter-spacing: 0.3em;
            animation: pulse 1.5s ease infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }

        /* Responsive */
        @media (max-width: 768px) {
            .glass-panel {
                padding: 2.5rem 2rem;
                margin: 1rem;
            }

            .logo-text {
                font-size: 1.8rem;
            }

            .main-title {
                font-size: 1.6rem;
            }

            .detail-item {
                font-size: 1rem;
            }
        }
    </style>
</head>
<body>
    <div class="loading-screen" id="loading">
        <span class="loading-text">ENTERING THE CASINO</span>
    </div>

    <div class="custom-cursor" id="cursor"></div>
    <div class="cursor-glow" id="cursor-glow"></div>

    <div id="canvas-container"></div>

    <div class="vignette"></div>

    <div class="overlay">
        <div class="glass-panel">
            <div class="logo-placeholder">
                <svg width="240" height="47" viewBox="0 0 478 94" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M452.942 67.4912L446.764 50.5141L444.856 44.7378L445.057 52.925V67.4912H436.367V28.3132H447.618L453.746 44.989L456.81 54.03L459.874 44.989L465.952 28.3132H476.952V67.4912H468.463V52.925L468.614 44.7378L466.755 50.5141L460.527 67.4912H452.942Z" fill="#D4AF37"/>
                    <path d="M408.654 59.8564C415.184 59.8564 420.257 55.5871 420.257 47.9022C420.257 40.2172 415.184 35.9479 408.654 35.9479C402.124 35.9479 397.051 40.2172 397.051 47.9022C397.051 55.5871 402.124 59.8564 408.654 59.8564ZM408.654 27.5095C420.307 27.5095 429.398 35.4456 429.398 47.9022C429.398 60.3587 420.307 68.2948 408.654 68.2948C397.001 68.2948 387.91 60.3587 387.91 47.9022C387.91 35.4456 397.001 27.5095 408.654 27.5095Z" fill="#D4AF37"/>
                    <path d="M360.917 59.8564C367.447 59.8564 372.52 55.5871 372.52 47.9022C372.52 40.2172 367.447 35.9479 360.917 35.9479C354.387 35.9479 349.314 40.2172 349.314 47.9022C349.314 55.5871 354.387 59.8564 360.917 59.8564ZM360.917 27.5095C372.57 27.5095 381.661 35.4456 381.661 47.9022C381.661 60.3587 372.57 68.2948 360.917 68.2948C349.264 68.2948 340.173 60.3587 340.173 47.9022C340.173 35.4456 349.264 27.5095 360.917 27.5095Z" fill="#D4AF37"/>
                    <path d="M319.613 28.3132V59.2035H337.645V67.4912H310.773V28.3132H319.613Z" fill="#D4AF37"/>
                    <path d="M279.868 53.3268V67.4912H271.028V28.3132H290.631C298.316 28.3132 302.535 34.2402 302.535 40.82C302.535 45.9935 299.773 50.9661 294.75 52.6739L303.741 67.4912H293.394L285.307 53.3268H279.868ZM279.868 45.0392H289.275C292.339 45.0392 293.595 42.8794 293.595 40.82C293.595 38.61 292.339 36.5506 289.275 36.5506H279.868V45.0392Z" fill="#D4AF37"/>
                    <path d="M233.347 28.3132H262.228V36.5506H242.187V43.2812H260.219V51.4684H242.187V59.2035H263.233V67.4912H233.347V28.3132Z" fill="#D4AF37"/>
                    <path d="M214.922 36.5506V67.4912H206.082V36.5506H194.479V28.3132H226.525V36.5506H214.922Z" fill="#D4AF37"/>
                    <path d="M160.959 28.4583L179.192 51.5632L178.991 43.0244V28.4583H187.63V67.6362H180.046L161.763 44.5313L162.014 53.07V67.6362H153.375V28.4583H160.959Z" fill="#D4AF37"/>
                    <path d="M134.309 32.7285V67.1619H125.469V32.7285H134.309Z" fill="#D4AF37"/>
                    <rect x="115.031" y="28.4583" width="29.4164" height="8.54025" fill="#D4AF37"/>
                    <rect x="115.031" y="58.9126" width="29.4164" height="8.54025" fill="#D4AF37"/>
                    <path d="M52.9759 76.2205C50.8662 67.6018 47.7165 55.3823 47.7165 46.9713C47.7165 38.5603 50.8663 26.3408 52.9759 17.7222C53.5968 15.1859 54.2413 12.5526 54.9029 9.65481C55.1494 8.5752 56.3387 7.99975 57.332 8.48868L64.3789 11.9576C65.307 12.4144 65.6225 13.5902 65.1557 14.5136C63.5283 17.7334 62.1974 22.3864 60.9901 26.6072C59.9164 30.3611 58.9404 33.7732 57.9406 35.531C56.1723 38.6402 55.8129 42.654 55.575 45.3104C55.5174 45.9546 55.4668 46.519 55.4051 46.9713C55.4668 47.4236 55.5174 47.988 55.575 48.6323C55.8129 51.2886 56.1723 55.3024 57.9406 58.4116C58.9404 60.1694 59.9163 63.5814 60.9901 67.3353C62.1974 71.5561 63.5283 76.2092 65.1557 79.429C65.6225 80.3525 65.307 81.5282 64.3789 81.9851L57.332 85.4539C56.3387 85.9429 55.1493 85.3674 54.9029 84.2878C54.2413 81.3899 53.5968 78.7567 52.9759 76.2205Z" fill="#D4AF37"/>
                    <path d="M58.9719 47.1421C59.1178 50.6235 61.4621 54.2355 64.2577 57.2163C67.1123 60.2602 69.8932 61.6571 73.4078 63.4226C75.1441 64.2948 77.0595 65.257 79.2513 66.5521C79.9199 66.9472 80.7888 66.7265 81.1701 66.0498L85.1307 59.0203C85.4854 58.3907 85.2895 57.5926 84.6592 57.2392C83.0104 56.3145 80.9343 55.3759 78.8126 54.4167C73.6615 52.0879 68.2421 49.6378 68.0182 46.9713C68.2421 44.3049 73.6615 41.8548 78.8126 39.526C80.9343 38.5668 83.0104 37.6282 84.6592 36.7035C85.2895 36.35 85.4854 35.5519 85.1307 34.9223L81.1701 27.8928C80.7888 27.2161 79.9199 26.9955 79.2513 27.3905C77.0595 28.6856 75.1442 29.6478 73.4079 30.52C69.8932 32.2855 67.1123 33.6825 64.2577 36.7263C61.4621 39.7071 59.1178 43.3191 58.9719 46.8006L58.9647 46.8006C58.9647 46.8574 58.9653 46.9144 58.9665 46.9713C58.9653 47.0283 58.9647 47.0852 58.9647 47.1421L58.9719 47.1421Z" fill="#D4AF37"/>
                    <path d="M44.6102 46.9713C44.6102 55.3823 41.4605 67.6018 39.3508 76.2205C38.7299 78.7567 38.0854 81.3899 37.4238 84.2878C37.1773 85.3674 35.988 85.9429 34.9947 85.4539L27.9478 81.9851C27.0197 81.5282 26.7042 80.3525 27.171 79.429C28.7984 76.2093 30.1293 71.5562 31.3366 67.3354C32.4103 63.5815 33.3863 60.1695 34.3861 58.4116C36.1544 55.3024 36.5138 51.2886 36.7517 48.6322L36.7517 48.632C36.8094 47.9879 36.8599 47.4235 36.9216 46.9713C36.8599 46.519 36.8093 45.9546 36.7517 45.3104C36.5138 42.6541 36.1544 38.6402 34.3861 35.531C33.3863 33.7732 32.4103 30.3611 31.3366 26.6072C30.1293 22.3864 28.7984 17.7334 27.171 14.5136C26.7042 13.5902 27.0197 12.4144 27.9478 11.9576L34.9947 8.48867C35.988 7.99974 37.1774 8.5752 37.4238 9.65481C38.0854 12.5526 38.7299 15.1858 39.3507 17.722C41.4604 26.3407 44.6102 38.5603 44.6102 46.9713Z" fill="#D4AF37"/>
                    <path d="M33.3548 47.1421C33.2089 50.6235 30.8646 54.2355 28.069 57.2163C25.2144 60.2602 22.4335 61.6571 18.9188 63.4226C17.1826 64.2948 15.2672 65.257 13.0753 66.5521C12.4067 66.9472 11.5379 66.7265 11.1566 66.0498L7.19603 59.0203C6.84129 58.3907 7.03723 57.5926 7.66745 57.2391C9.31629 56.3145 11.3924 55.3759 13.5141 54.4167C18.6652 52.0879 24.0846 49.6378 24.3085 46.9713C24.0846 44.3049 18.6652 41.8547 13.5141 39.5259C11.3924 38.5668 9.31628 37.6281 7.66745 36.7035C7.03724 36.35 6.84129 35.5519 7.19603 34.9223L11.1566 27.8928C11.5379 27.2161 12.4068 26.9955 13.0754 27.3905C15.2672 28.6856 17.1826 29.6478 18.9188 30.52C22.4335 32.2855 25.2144 33.6824 28.069 36.7263C30.8646 39.7071 33.2089 43.3191 33.3548 46.8006L33.362 46.8006C33.362 46.8574 33.3614 46.9144 33.3602 46.9713C33.3614 47.0283 33.362 47.0852 33.362 47.1421L33.3548 47.1421Z" fill="#D4AF37"/>
                </svg>
            </div>

            <p class="invite-line">invites you and your friends</p>

            <h1 class="main-title" id="main-title">Welcome to the Betting Table</h1>

            <div class="details">
                <p class="detail-item dresscode">Dresscode: Black Tie</p>
                <div class="divider"></div>
                <p class="detail-item">15th January 2026</p>
                <p class="detail-item">19:00</p>
                <div class="divider"></div>
                <p class="detail-item location">Leuschnerdamm 13, Berlin</p>
            </div>
        </div>
    </div>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // ============================================
        // CASINO ROYALE - Interactive 3D Invitation
        // ============================================

        // Global variables
        let scene, camera, renderer;
        let chips = [];
        let cards = [];
        let particles;
        let mouseX = 0, mouseY = 0;
        let targetMouseX = 0, targetMouseY = 0;
        let windowHalfX = window.innerWidth / 2;
        let windowHalfY = window.innerHeight / 2;

        // Raycaster for click detection
        const raycaster = new THREE.Raycaster();
        const clickMouse = new THREE.Vector2();

        // Spark systems for bullet impacts
        let sparkSystems = [];

        // Interloom logo texture for chips
        let logoTexture = null;

        // Cursor elements
        const cursor = document.getElementById('cursor');
        const cursorGlow = document.getElementById('cursor-glow');

        // Initialize everything
        init();
        animate();

        // Create texture from SVG
        function createLogoTexture() {
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                const size = 256;
                canvas.width = size;
                canvas.height = size;
                const ctx = canvas.getContext('2d');

                // Interloom symbol SVG with gold color
                const svgString = `
                    <svg width="${size}" height="${size}" viewBox="0 0 94 94" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M52.9759 76.2205C50.8662 67.6018 47.7165 55.3823 47.7165 46.9713C47.7165 38.5603 50.8663 26.3408 52.9759 17.7222C53.5968 15.1859 54.2413 12.5526 54.9029 9.65481C55.1494 8.5752 56.3387 7.99975 57.332 8.48868L64.3789 11.9576C65.307 12.4144 65.6225 13.5902 65.1557 14.5136C63.5283 17.7334 62.1974 22.3864 60.9901 26.6072C59.9164 30.3611 58.9404 33.7732 57.9406 35.531C56.1723 38.6402 55.8129 42.654 55.575 45.3104C55.5174 45.9546 55.4668 46.519 55.4051 46.9713C55.4668 47.4236 55.5174 47.988 55.575 48.6323C55.8129 51.2886 56.1723 55.3024 57.9406 58.4116C58.9404 60.1694 59.9163 63.5814 60.9901 67.3353C62.1974 71.5561 63.5283 76.2092 65.1557 79.429C65.6225 80.3525 65.307 81.5282 64.3789 81.9851L57.332 85.4539C56.3387 85.9429 55.1493 85.3674 54.9029 84.2878C54.2413 81.3899 53.5968 78.7567 52.9759 76.2205Z" fill="#D4AF37"/>
                        <path d="M58.9719 47.1421C59.1178 50.6235 61.4621 54.2355 64.2577 57.2163C67.1123 60.2602 69.8932 61.6571 73.4078 63.4226C75.1441 64.2948 77.0595 65.257 79.2513 66.5521C79.9199 66.9472 80.7888 66.7265 81.1701 66.0498L85.1307 59.0203C85.4854 58.3907 85.2895 57.5926 84.6592 57.2392C83.0104 56.3145 80.9343 55.3759 78.8126 54.4167C73.6615 52.0879 68.2421 49.6378 68.0182 46.9713C68.2421 44.3049 73.6615 41.8548 78.8126 39.526C80.9343 38.5668 83.0104 37.6282 84.6592 36.7035C85.2895 36.35 85.4854 35.5519 85.1307 34.9223L81.1701 27.8928C80.7888 27.2161 79.9199 26.9955 79.2513 27.3905C77.0595 28.6856 75.1442 29.6478 73.4079 30.52C69.8932 32.2855 67.1123 33.6825 64.2577 36.7263C61.4621 39.7071 59.1178 43.3191 58.9719 46.8006L58.9647 46.8006C58.9647 46.8574 58.9653 46.9144 58.9665 46.9713C58.9653 47.0283 58.9647 47.0852 58.9647 47.1421L58.9719 47.1421Z" fill="#D4AF37"/>
                        <path d="M44.6102 46.9713C44.6102 55.3823 41.4605 67.6018 39.3508 76.2205C38.7299 78.7567 38.0854 81.3899 37.4238 84.2878C37.1773 85.3674 35.988 85.9429 34.9947 85.4539L27.9478 81.9851C27.0197 81.5282 26.7042 80.3525 27.171 79.429C28.7984 76.2093 30.1293 71.5562 31.3366 67.3354C32.4103 63.5815 33.3863 60.1695 34.3861 58.4116C36.1544 55.3024 36.5138 51.2886 36.7517 48.6322L36.7517 48.632C36.8094 47.9879 36.8599 47.4235 36.9216 46.9713C36.8599 46.519 36.8093 45.9546 36.7517 45.3104C36.5138 42.6541 36.1544 38.6402 34.3861 35.531C33.3863 33.7732 32.4103 30.3611 31.3366 26.6072C30.1293 22.3864 28.7984 17.7334 27.171 14.5136C26.7042 13.5902 27.0197 12.4144 27.9478 11.9576L34.9947 8.48867C35.988 7.99974 37.1774 8.5752 37.4238 9.65481C38.0854 12.5526 38.7299 15.1858 39.3507 17.722C41.4604 26.3407 44.6102 38.5603 44.6102 46.9713Z" fill="#D4AF37"/>
                        <path d="M33.3548 47.1421C33.2089 50.6235 30.8646 54.2355 28.069 57.2163C25.2144 60.2602 22.4335 61.6571 18.9188 63.4226C17.1826 64.2948 15.2672 65.257 13.0753 66.5521C12.4067 66.9472 11.5379 66.7265 11.1566 66.0498L7.19603 59.0203C6.84129 58.3907 7.03723 57.5926 7.66745 57.2391C9.31629 56.3145 11.3924 55.3759 13.5141 54.4167C18.6652 52.0879 24.0846 49.6378 24.3085 46.9713C24.0846 44.3049 18.6652 41.8547 13.5141 39.5259C11.3924 38.5668 9.31628 37.6281 7.66745 36.7035C7.03724 36.35 6.84129 35.5519 7.19603 34.9223L11.1566 27.8928C11.5379 27.2161 12.4068 26.9955 13.0754 27.3905C15.2672 28.6856 17.1826 29.6478 18.9188 30.52C22.4335 32.2855 25.2144 33.6824 28.069 36.7263C30.8646 39.7071 33.2089 43.3191 33.3548 46.8006L33.362 46.8006C33.362 46.8574 33.3614 46.9144 33.3602 46.9713C33.3614 47.0283 33.362 47.0852 33.362 47.1421L33.3548 47.1421Z" fill="#D4AF37"/>
                    </svg>
                `;

                const img = new Image();
                const blob = new Blob([svgString], { type: 'image/svg+xml' });
                const url = URL.createObjectURL(blob);

                img.onload = () => {
                    ctx.drawImage(img, 0, 0, size, size);
                    URL.revokeObjectURL(url);

                    const texture = new THREE.CanvasTexture(canvas);
                    texture.needsUpdate = true;
                    resolve(texture);
                };

                img.src = url;
            });
        }

        async function init() {
            // Create logo texture first
            logoTexture = await createLogoTexture();

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050808);
            scene.fog = new THREE.FogExp2(0x050808, 0.035);

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 30;

            // Renderer
            renderer = new THREE.WebGLRenderer({
                antialias: true,
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Lighting
            setupLighting();

            // Create objects
            createChips();
            createCards();
            createParticles();
            createAmbientParticles();

            // Event listeners
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('click', onChipClick);
            window.addEventListener('resize', onWindowResize);

            // Setup text animation
            setupTextAnimation();

            // Hide loading screen
            setTimeout(() => {
                document.getElementById('loading').classList.add('hidden');
            }, 800);
        }

        function setupLighting() {
            // Ambient light - very dim
            const ambient = new THREE.AmbientLight(0x1a1a2e, 0.3);
            scene.add(ambient);

            // Main spotlight - golden
            const spotLight1 = new THREE.SpotLight(0xD4AF37, 2);
            spotLight1.position.set(0, 30, 20);
            spotLight1.angle = Math.PI / 4;
            spotLight1.penumbra = 0.5;
            spotLight1.decay = 1.5;
            spotLight1.distance = 100;
            scene.add(spotLight1);

            // Side spotlight - warm
            const spotLight2 = new THREE.SpotLight(0xFFD700, 1);
            spotLight2.position.set(-30, 20, 10);
            spotLight2.angle = Math.PI / 5;
            spotLight2.penumbra = 0.7;
            spotLight2.decay = 1.5;
            scene.add(spotLight2);

            // Rim light - cool
            const spotLight3 = new THREE.SpotLight(0x4a6741, 0.8);
            spotLight3.position.set(30, -10, 15);
            spotLight3.angle = Math.PI / 4;
            spotLight3.penumbra = 0.6;
            scene.add(spotLight3);

            // Point lights for highlights
            const pointLight1 = new THREE.PointLight(0xD4AF37, 1, 50);
            pointLight1.position.set(10, 10, 20);
            scene.add(pointLight1);

            const pointLight2 = new THREE.PointLight(0xB8860B, 0.8, 40);
            pointLight2.position.set(-15, -5, 15);
            scene.add(pointLight2);
        }

        function createChips() {
            const chipColors = [
                { main: 0xD4AF37, rim: 0xFFD700 },  // Gold
                { main: 0x8B0000, rim: 0xD4AF37 },  // Red
                { main: 0x1a1a1a, rim: 0xD4AF37 },  // Black
                { main: 0x0d3b0d, rim: 0xD4AF37 },  // Green
                { main: 0x4169E1, rim: 0xD4AF37 },  // Blue
            ];

            for (let i = 0; i < 18; i++) {
                const colorSet = chipColors[Math.floor(Math.random() * chipColors.length)];
                const chip = createChip(colorSet);

                // Random position in 3D space
                chip.position.x = (Math.random() - 0.5) * 50;
                chip.position.y = (Math.random() - 0.5) * 35;
                chip.position.z = (Math.random() - 0.5) * 30 - 5;

                // Random initial rotation
                chip.rotation.x = Math.random() * Math.PI;
                chip.rotation.y = Math.random() * Math.PI;
                chip.rotation.z = Math.random() * Math.PI;

                // Store animation parameters
                chip.userData = {
                    originalPos: chip.position.clone(),
                    rotationSpeed: {
                        x: (Math.random() - 0.5) * 0.01,
                        y: (Math.random() - 0.5) * 0.02,
                        z: (Math.random() - 0.5) * 0.01
                    },
                    floatOffset: Math.random() * Math.PI * 2,
                    floatSpeed: 0.3 + Math.random() * 0.4,
                    floatAmplitude: 0.5 + Math.random() * 1,
                    magnetStrength: 0.02 + Math.random() * 0.03,
                    // Bullet hit state
                    isHit: false,
                    hitTime: 0,
                    hitVelocity: { x: 0, y: 0, z: 0 },
                    hitSpin: { x: 0, y: 0, z: 0 }
                };

                chips.push(chip);
                scene.add(chip);
            }
        }

        function createChip(colorSet) {
            const group = new THREE.Group();

            // Main chip body
            const chipGeometry = new THREE.CylinderGeometry(1.2, 1.2, 0.2, 32);
            const chipMaterial = new THREE.MeshStandardMaterial({
                color: colorSet.main,
                metalness: 0.3,
                roughness: 0.4,
                emissive: colorSet.main,
                emissiveIntensity: 0.1
            });
            const chipMesh = new THREE.Mesh(chipGeometry, chipMaterial);
            group.add(chipMesh);

            // Rim (gold edge)
            const rimGeometry = new THREE.TorusGeometry(1.2, 0.08, 8, 32);
            const rimMaterial = new THREE.MeshStandardMaterial({
                color: colorSet.rim,
                metalness: 0.9,
                roughness: 0.1,
                emissive: colorSet.rim,
                emissiveIntensity: 0.3
            });

            // Top rim
            const rimTop = new THREE.Mesh(rimGeometry, rimMaterial);
            rimTop.rotation.x = Math.PI / 2;
            rimTop.position.y = 0.1;
            group.add(rimTop);

            // Bottom rim
            const rimBottom = new THREE.Mesh(rimGeometry, rimMaterial);
            rimBottom.rotation.x = Math.PI / 2;
            rimBottom.position.y = -0.1;
            group.add(rimBottom);

            // Center decoration with Interloom logo
            const centerGeometry = new THREE.CircleGeometry(0.75, 32);

            // Create material with logo texture
            const centerMaterial = new THREE.MeshStandardMaterial({
                map: logoTexture,
                transparent: true,
                metalness: 0.5,
                roughness: 0.3,
                emissive: colorSet.rim,
                emissiveIntensity: 0.15,
                side: THREE.DoubleSide
            });

            const centerTop = new THREE.Mesh(centerGeometry, centerMaterial);
            centerTop.rotation.x = -Math.PI / 2;
            centerTop.position.y = 0.11;
            group.add(centerTop);

            const centerBottom = new THREE.Mesh(centerGeometry, centerMaterial);
            centerBottom.rotation.x = Math.PI / 2;
            centerBottom.position.y = -0.11;
            group.add(centerBottom);

            return group;
        }

        function createCards() {
            const cardWidth = 2.5;
            const cardHeight = 3.5;

            for (let i = 0; i < 10; i++) {
                const card = createCard(cardWidth, cardHeight, i);

                // Random position
                card.position.x = (Math.random() - 0.5) * 45;
                card.position.y = (Math.random() - 0.5) * 30;
                card.position.z = (Math.random() - 0.5) * 25 - 8;

                // Random rotation
                card.rotation.x = (Math.random() - 0.5) * 0.5;
                card.rotation.y = (Math.random() - 0.5) * Math.PI;
                card.rotation.z = (Math.random() - 0.5) * 0.3;

                // Animation parameters
                card.userData = {
                    originalPos: card.position.clone(),
                    originalRot: card.rotation.clone(),
                    tumbleSpeed: {
                        x: (Math.random() - 0.5) * 0.005,
                        y: (Math.random() - 0.5) * 0.008,
                        z: (Math.random() - 0.5) * 0.003
                    },
                    floatOffset: Math.random() * Math.PI * 2,
                    floatSpeed: 0.2 + Math.random() * 0.3,
                    floatAmplitude: 0.3 + Math.random() * 0.6,
                    magnetStrength: 0.015 + Math.random() * 0.02,
                    // Bullet hit state
                    isHit: false,
                    hitTime: 0,
                    hitVelocity: { x: 0, y: 0, z: 0 },
                    hitSpin: { x: 0, y: 0, z: 0 }
                };

                cards.push(card);
                scene.add(card);
            }
        }

        function createCard(width, height, index) {
            const group = new THREE.Group();

            // Card geometry with slight bevel
            const shape = new THREE.Shape();
            const radius = 0.1;
            shape.moveTo(-width/2 + radius, -height/2);
            shape.lineTo(width/2 - radius, -height/2);
            shape.quadraticCurveTo(width/2, -height/2, width/2, -height/2 + radius);
            shape.lineTo(width/2, height/2 - radius);
            shape.quadraticCurveTo(width/2, height/2, width/2 - radius, height/2);
            shape.lineTo(-width/2 + radius, height/2);
            shape.quadraticCurveTo(-width/2, height/2, -width/2, height/2 - radius);
            shape.lineTo(-width/2, -height/2 + radius);
            shape.quadraticCurveTo(-width/2, -height/2, -width/2 + radius, -height/2);

            const extrudeSettings = {
                depth: 0.02,
                bevelEnabled: true,
                bevelThickness: 0.01,
                bevelSize: 0.01,
                bevelSegments: 2
            };

            const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);

            // Card face material (front)
            const frontMaterial = new THREE.MeshStandardMaterial({
                color: 0xFFF8E7,
                metalness: 0.1,
                roughness: 0.3,
                emissive: 0xFFF8E7,
                emissiveIntensity: 0.05
            });

            // Card back material
            const backMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B0000,
                metalness: 0.2,
                roughness: 0.4,
                emissive: 0x8B0000,
                emissiveIntensity: 0.1
            });

            const cardMesh = new THREE.Mesh(geometry, [frontMaterial, backMaterial]);
            group.add(cardMesh);

            // Add suit symbol
            const suits = ['spade', 'heart', 'diamond', 'club'];
            const suit = suits[index % 4];
            const suitColor = (suit === 'heart' || suit === 'diamond') ? 0xB22222 : 0x1a1a1a;

            // Create suit geometry
            const suitGeometry = createSuitGeometry(suit);
            const suitMaterial = new THREE.MeshBasicMaterial({
                color: suitColor,
                side: THREE.DoubleSide
            });

            if (suitGeometry) {
                const suitMesh = new THREE.Mesh(suitGeometry, suitMaterial);
                suitMesh.position.z = 0.025;
                suitMesh.scale.set(0.4, 0.4, 1);
                group.add(suitMesh);
            }

            return group;
        }

        function createSuitGeometry(suit) {
            const shape = new THREE.Shape();

            if (suit === 'spade') {
                shape.moveTo(0, 0.5);
                shape.bezierCurveTo(-0.5, 0.2, -0.5, -0.3, 0, -0.1);
                shape.bezierCurveTo(0.5, -0.3, 0.5, 0.2, 0, 0.5);
                shape.moveTo(-0.1, -0.1);
                shape.lineTo(0.1, -0.1);
                shape.lineTo(0.05, -0.5);
                shape.lineTo(-0.05, -0.5);
                shape.lineTo(-0.1, -0.1);
            } else if (suit === 'heart') {
                shape.moveTo(0, -0.4);
                shape.bezierCurveTo(-0.5, 0.1, -0.5, 0.5, 0, 0.3);
                shape.bezierCurveTo(0.5, 0.5, 0.5, 0.1, 0, -0.4);
            } else if (suit === 'diamond') {
                shape.moveTo(0, 0.5);
                shape.lineTo(-0.3, 0);
                shape.lineTo(0, -0.5);
                shape.lineTo(0.3, 0);
                shape.lineTo(0, 0.5);
            } else if (suit === 'club') {
                // Simplified club
                shape.absarc(0, 0.15, 0.2, 0, Math.PI * 2);
                shape.absarc(-0.2, -0.1, 0.2, 0, Math.PI * 2);
                shape.absarc(0.2, -0.1, 0.2, 0, Math.PI * 2);
            }

            return new THREE.ShapeGeometry(shape);
        }

        function createParticles() {
            // Gold dust particles
            const particleCount = 500;
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);

            const goldColor = new THREE.Color(0xD4AF37);
            const warmGold = new THREE.Color(0xFFD700);

            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 80;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 60;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 50;

                const color = Math.random() > 0.5 ? goldColor : warmGold;
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;

                sizes[i] = Math.random() * 0.15 + 0.05;
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const material = new THREE.PointsMaterial({
                size: 0.1,
                vertexColors: true,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });

            particles = new THREE.Points(geometry, material);
            particles.userData = { originalPositions: positions.slice() };
            scene.add(particles);
        }

        function createAmbientParticles() {
            // Additional floating particles for atmosphere
            const particleCount = 200;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 100;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 70;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 60;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            const material = new THREE.PointsMaterial({
                size: 0.08,
                color: 0xFFFFFF,
                transparent: true,
                opacity: 0.3,
                blending: THREE.AdditiveBlending
            });

            const ambientParticles = new THREE.Points(geometry, material);
            ambientParticles.userData = { isAmbient: true };
            scene.add(ambientParticles);
        }

        function setupTextAnimation() {
            const title = document.getElementById('main-title');
            const text = title.textContent;
            title.textContent = '';

            const words = text.split(' ');
            let charIndex = 0;

            words.forEach((word, wordIndex) => {
                // Create a wrapper span for each word to prevent breaking
                const wordSpan = document.createElement('span');
                wordSpan.style.display = 'inline-block';
                wordSpan.style.whiteSpace = 'nowrap';

                // Add each letter inside the word wrapper
                for (let i = 0; i < word.length; i++) {
                    const letterSpan = document.createElement('span');
                    letterSpan.textContent = word[i];
                    letterSpan.style.animationDelay = `${2 + charIndex * 0.05}s`;
                    wordSpan.appendChild(letterSpan);
                    charIndex++;
                }

                title.appendChild(wordSpan);

                // Add space between words (except after the last word)
                if (wordIndex < words.length - 1) {
                    const spaceSpan = document.createElement('span');
                    spaceSpan.innerHTML = '&nbsp;';
                    spaceSpan.style.animationDelay = `${2 + charIndex * 0.05}s`;
                    title.appendChild(spaceSpan);
                    charIndex++;
                }
            });
        }

        function onMouseMove(event) {
            targetMouseX = (event.clientX - windowHalfX) / windowHalfX;
            targetMouseY = (event.clientY - windowHalfY) / windowHalfY;

            // Update custom cursor
            cursor.style.left = event.clientX + 'px';
            cursor.style.top = event.clientY + 'px';
            cursorGlow.style.left = event.clientX + 'px';
            cursorGlow.style.top = event.clientY + 'px';
        }

        function onWindowResize() {
            windowHalfX = window.innerWidth / 2;
            windowHalfY = window.innerHeight / 2;

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onChipClick(event) {
            // Calculate mouse position in normalized device coordinates
            clickMouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            clickMouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Update the raycaster
            raycaster.setFromCamera(clickMouse, camera);

            // Get all chip and card meshes for intersection testing
            const targetMeshes = [];

            chips.forEach(chip => {
                chip.traverse(child => {
                    if (child.isMesh) {
                        child.userData.parentObject = chip;
                        child.userData.objectType = 'chip';
                        targetMeshes.push(child);
                    }
                });
            });

            cards.forEach(card => {
                card.traverse(child => {
                    if (child.isMesh) {
                        child.userData.parentObject = card;
                        child.userData.objectType = 'card';
                        targetMeshes.push(child);
                    }
                });
            });

            // Check for intersections
            const intersects = raycaster.intersectObjects(targetMeshes);

            if (intersects.length > 0) {
                const hitPoint = intersects[0].point;
                const hitObject = intersects[0].object.userData.parentObject;

                if (hitObject && !hitObject.userData.isHit) {
                    // Trigger bullet hit effect
                    bulletHitObject(hitObject, hitPoint);
                    // Create sparks at impact point
                    createSparks(hitPoint);
                }
            }
        }

        function bulletHitObject(obj, hitPoint) {
            const data = obj.userData;
            data.isHit = true;
            data.hitTime = Date.now();

            // Calculate hit direction (from camera)
            const direction = new THREE.Vector3();
            direction.subVectors(hitPoint, camera.position).normalize();

            // Apply violent velocity (knocked back by bullet)
            const force = 15 + Math.random() * 10;
            data.hitVelocity = {
                x: direction.x * force + (Math.random() - 0.5) * 5,
                y: direction.y * force + Math.random() * 8, // Upward bias
                z: direction.z * force + (Math.random() - 0.5) * 5
            };

            // Apply violent spin
            data.hitSpin = {
                x: (Math.random() - 0.5) * 2,
                y: (Math.random() - 0.5) * 2,
                z: (Math.random() - 0.5) * 2
            };
        }

        function createSparks(position) {
            const sparkCount = 30;
            const positions = new Float32Array(sparkCount * 3);
            const velocities = [];
            const colors = new Float32Array(sparkCount * 3);

            const goldColor = new THREE.Color(0xFFD700);
            const orangeColor = new THREE.Color(0xFF6600);
            const whiteColor = new THREE.Color(0xFFFFFF);

            for (let i = 0; i < sparkCount; i++) {
                // Start at impact point
                positions[i * 3] = position.x;
                positions[i * 3 + 1] = position.y;
                positions[i * 3 + 2] = position.z;

                // Random velocity in all directions
                velocities.push({
                    x: (Math.random() - 0.5) * 20,
                    y: (Math.random() - 0.5) * 20,
                    z: (Math.random() - 0.5) * 20
                });

                // Random spark colors (gold, orange, white)
                const colorChoice = Math.random();
                const color = colorChoice < 0.5 ? goldColor : (colorChoice < 0.8 ? orangeColor : whiteColor);
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 0.15,
                vertexColors: true,
                transparent: true,
                opacity: 1,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });

            const sparks = new THREE.Points(geometry, material);
            sparks.userData = {
                velocities: velocities,
                birthTime: Date.now(),
                lifetime: 800 // milliseconds
            };

            scene.add(sparks);
            sparkSystems.push(sparks);
        }

        function updateSparks() {
            const now = Date.now();

            for (let i = sparkSystems.length - 1; i >= 0; i--) {
                const sparks = sparkSystems[i];
                const data = sparks.userData;
                const age = now - data.birthTime;

                if (age > data.lifetime) {
                    // Remove expired sparks
                    scene.remove(sparks);
                    sparks.geometry.dispose();
                    sparks.material.dispose();
                    sparkSystems.splice(i, 1);
                    continue;
                }

                // Update spark positions
                const positions = sparks.geometry.attributes.position.array;
                const velocities = data.velocities;
                const progress = age / data.lifetime;

                // Fade out
                sparks.material.opacity = 1 - progress;

                for (let j = 0; j < velocities.length; j++) {
                    const vel = velocities[j];

                    // Apply velocity with gravity and drag
                    positions[j * 3] += vel.x * 0.016;
                    positions[j * 3 + 1] += vel.y * 0.016;
                    positions[j * 3 + 2] += vel.z * 0.016;

                    // Apply gravity
                    vel.y -= 0.5;

                    // Apply drag
                    vel.x *= 0.98;
                    vel.y *= 0.98;
                    vel.z *= 0.98;
                }

                sparks.geometry.attributes.position.needsUpdate = true;
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            const time = Date.now() * 0.001;

            // Smooth mouse following
            mouseX += (targetMouseX - mouseX) * 0.05;
            mouseY += (targetMouseY - mouseY) * 0.05;

            // Camera movement based on mouse (subtle tilt)
            camera.position.x = mouseX * 3;
            camera.position.y = -mouseY * 2;
            camera.lookAt(scene.position);

            // Animate chips
            chips.forEach((chip, index) => {
                const data = chip.userData;

                if (data.isHit) {
                    // Bullet hit animation
                    const hitAge = (Date.now() - data.hitTime) / 1000;
                    const recoveryTime = 3; // seconds to recover

                    if (hitAge < recoveryTime) {
                        // Apply hit velocity with decay
                        const decay = Math.exp(-hitAge * 2);

                        chip.position.x += data.hitVelocity.x * 0.016 * decay;
                        chip.position.y += data.hitVelocity.y * 0.016 * decay;
                        chip.position.z += data.hitVelocity.z * 0.016 * decay;

                        // Apply gravity to velocity
                        data.hitVelocity.y -= 15 * 0.016;

                        // Violent spin
                        chip.rotation.x += data.hitSpin.x * decay;
                        chip.rotation.y += data.hitSpin.y * decay;
                        chip.rotation.z += data.hitSpin.z * decay;

                        // Gradually return to original position
                        const returnStrength = hitAge / recoveryTime * 0.02;
                        chip.position.x += (data.originalPos.x - chip.position.x) * returnStrength;
                        chip.position.y += (data.originalPos.y - chip.position.y) * returnStrength;
                        chip.position.z += (data.originalPos.z - chip.position.z) * returnStrength;
                    } else {
                        // Recovery complete
                        data.isHit = false;
                        data.hitVelocity = { x: 0, y: 0, z: 0 };
                        data.hitSpin = { x: 0, y: 0, z: 0 };
                    }
                } else {
                    // Normal floating animation
                    // Rotation
                    chip.rotation.x += data.rotationSpeed.x;
                    chip.rotation.y += data.rotationSpeed.y;
                    chip.rotation.z += data.rotationSpeed.z;

                    // Floating motion
                    const floatY = Math.sin(time * data.floatSpeed + data.floatOffset) * data.floatAmplitude;
                    const floatX = Math.cos(time * data.floatSpeed * 0.5 + data.floatOffset) * data.floatAmplitude * 0.5;

                    // Magnetic attraction to cursor
                    const magnetX = mouseX * 10 * data.magnetStrength * (30 - Math.abs(chip.position.z));
                    const magnetY = -mouseY * 8 * data.magnetStrength * (30 - Math.abs(chip.position.z));

                    chip.position.x = data.originalPos.x + floatX + magnetX;
                    chip.position.y = data.originalPos.y + floatY + magnetY;
                }
            });

            // Animate cards
            cards.forEach((card, index) => {
                const data = card.userData;

                if (data.isHit) {
                    // Bullet hit animation
                    const hitAge = (Date.now() - data.hitTime) / 1000;
                    const recoveryTime = 3; // seconds to recover

                    if (hitAge < recoveryTime) {
                        // Apply hit velocity with decay
                        const decay = Math.exp(-hitAge * 2);

                        card.position.x += data.hitVelocity.x * 0.016 * decay;
                        card.position.y += data.hitVelocity.y * 0.016 * decay;
                        card.position.z += data.hitVelocity.z * 0.016 * decay;

                        // Apply gravity to velocity
                        data.hitVelocity.y -= 15 * 0.016;

                        // Violent spin
                        card.rotation.x += data.hitSpin.x * decay;
                        card.rotation.y += data.hitSpin.y * decay;
                        card.rotation.z += data.hitSpin.z * decay;

                        // Gradually return to original position
                        const returnStrength = hitAge / recoveryTime * 0.02;
                        card.position.x += (data.originalPos.x - card.position.x) * returnStrength;
                        card.position.y += (data.originalPos.y - card.position.y) * returnStrength;
                        card.position.z += (data.originalPos.z - card.position.z) * returnStrength;
                    } else {
                        // Recovery complete
                        data.isHit = false;
                        data.hitVelocity = { x: 0, y: 0, z: 0 };
                        data.hitSpin = { x: 0, y: 0, z: 0 };
                    }
                } else {
                    // Normal animation
                    // Slow tumble
                    card.rotation.x += data.tumbleSpeed.x;
                    card.rotation.y += data.tumbleSpeed.y;
                    card.rotation.z += data.tumbleSpeed.z;

                    // Floating
                    const floatY = Math.sin(time * data.floatSpeed + data.floatOffset) * data.floatAmplitude;
                    const floatX = Math.cos(time * data.floatSpeed * 0.7 + data.floatOffset) * data.floatAmplitude * 0.3;

                    // Magnetic effect
                    const magnetX = mouseX * 8 * data.magnetStrength * (25 - Math.abs(card.position.z));
                    const magnetY = -mouseY * 6 * data.magnetStrength * (25 - Math.abs(card.position.z));

                    card.position.x = data.originalPos.x + floatX + magnetX;
                    card.position.y = data.originalPos.y + floatY + magnetY;
                }
            });

            // Animate particles
            if (particles) {
                const positions = particles.geometry.attributes.position.array;
                const originalPositions = particles.userData.originalPositions;

                for (let i = 0; i < positions.length; i += 3) {
                    // Gentle floating
                    positions[i + 1] = originalPositions[i + 1] + Math.sin(time * 0.5 + i) * 0.5;

                    // Subtle drift toward cursor
                    positions[i] = originalPositions[i] + mouseX * 2;
                }

                particles.geometry.attributes.position.needsUpdate = true;
                particles.rotation.y = time * 0.02;
            }

            // Update spark effects
            updateSparks();

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
